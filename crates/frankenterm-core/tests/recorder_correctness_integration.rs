//! Cross-module integration tests for the flight recorder correctness stack.
//!
//! Wires up `sequence_model`, `event_id`, `recorder_invariants`, and `recording`
//! to verify the full correctness pipeline:
//! - Sequences assigned by SequenceAssigner produce valid monotonic streams
//! - Deterministic event IDs generated by event_id::generate_event_id_v1 are unique
//! - Causal correlation chains built by CorrelationTracker pass invariant checks
//! - RecorderMergeKey ordering is preserved through the full pipeline
//! - Replay determinism holds for shuffled and re-sorted event sets
//! - ClockSkewDetector anomalies align with InvariantChecker violations
//!
//! Bead: ft-oegrb.7.3 (recorder invariants integration)

use frankenterm_core::event_id::{RecorderMergeKey, StreamKind, generate_event_id_v1};
use frankenterm_core::recorder_invariants::{
    InvariantChecker, InvariantCheckerConfig, ViolationKind, ViolationSeverity,
    verify_replay_determinism,
};
use frankenterm_core::recording::{
    RECORDER_EVENT_SCHEMA_VERSION_V1, RecorderEvent, RecorderEventCausality, RecorderEventPayload,
    RecorderEventSource, RecorderIngressKind, RecorderLifecyclePhase, RecorderRedactionLevel,
    RecorderSegmentKind, RecorderTextEncoding,
};
use frankenterm_core::sequence_model::{
    CorrelationContext, CorrelationTracker, ReplayOrder, SequenceAssigner, validate_replay_order,
};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/// Build a RecorderEvent from sequence_model outputs with deterministic ID.
fn build_event(
    pane_id: u64,
    pane_seq: u64,
    occurred_at_ms: u64,
    payload: RecorderEventPayload,
    causality: RecorderEventCausality,
) -> RecorderEvent {
    let mut event = RecorderEvent {
        schema_version: RECORDER_EVENT_SCHEMA_VERSION_V1.to_string(),
        event_id: String::new(), // filled below
        pane_id,
        session_id: Some("integration-test".into()),
        workflow_id: None,
        correlation_id: None,
        source: RecorderEventSource::RobotMode,
        occurred_at_ms,
        recorded_at_ms: occurred_at_ms + 1,
        sequence: pane_seq,
        causality,
        payload,
    };
    event.event_id = generate_event_id_v1(&event);
    event
}

fn ingress_payload(text: &str) -> RecorderEventPayload {
    RecorderEventPayload::IngressText {
        text: text.into(),
        encoding: RecorderTextEncoding::Utf8,
        redaction: RecorderRedactionLevel::None,
        ingress_kind: RecorderIngressKind::SendText,
    }
}

fn egress_payload(text: &str) -> RecorderEventPayload {
    RecorderEventPayload::EgressOutput {
        text: text.into(),
        encoding: RecorderTextEncoding::Utf8,
        redaction: RecorderRedactionLevel::None,
        segment_kind: RecorderSegmentKind::Delta,
        is_gap: false,
    }
}

fn lifecycle_payload(phase: RecorderLifecyclePhase) -> RecorderEventPayload {
    RecorderEventPayload::LifecycleMarker {
        lifecycle_phase: phase,
        reason: None,
        details: serde_json::Value::Null,
    }
}

fn causality_from_context(ctx: &CorrelationContext) -> RecorderEventCausality {
    RecorderEventCausality {
        parent_event_id: ctx.parent_event_id.clone(),
        trigger_event_id: ctx.trigger_event_id.clone(),
        root_event_id: ctx.root_event_id.clone(),
    }
}

fn empty_causality() -> RecorderEventCausality {
    RecorderEventCausality {
        parent_event_id: None,
        trigger_event_id: None,
        root_event_id: None,
    }
}

// ---------------------------------------------------------------------------
// Integration tests: full pipeline
// ---------------------------------------------------------------------------

#[test]
fn single_pane_sequential_events_pass_all_invariants() {
    let assigner = SequenceAssigner::new();
    let tracker = CorrelationTracker::new();

    let mut events = Vec::new();
    let pane_id = 0u64;

    for i in 0u64..20 {
        let (pane_seq, _global_seq) = assigner.assign(pane_id);
        let text = format!("command-{}", i);
        let mut event = build_event(
            pane_id,
            pane_seq,
            1000 + i * 10,
            ingress_payload(&text),
            empty_causality(),
        );
        // Wire up causality from CorrelationTracker
        let ctx = tracker.build_context(pane_id, &event.event_id, None, None);
        event.causality = causality_from_context(&ctx);
        events.push(event);
    }

    let checker = InvariantChecker::new();
    let report = checker.check(&events);

    assert!(report.passed, "violations: {:?}", report.violations);
    assert_eq!(report.events_checked, 20);
    assert_eq!(report.panes_observed, 1);
}

#[test]
fn multi_pane_interleaved_events_pass_invariants() {
    let assigner = SequenceAssigner::new();
    let tracker = CorrelationTracker::new();

    let mut events = Vec::new();

    for round in 0u64..10 {
        for pane_id in 0u64..5 {
            let (pane_seq, _global_seq) = assigner.assign(pane_id);
            let ts = 1000 + round * 50 + pane_id;
            let text = format!("pane-{}-cmd-{}", pane_id, round);
            let mut event = build_event(
                pane_id,
                pane_seq,
                ts,
                ingress_payload(&text),
                empty_causality(),
            );
            let ctx = tracker.build_context(pane_id, &event.event_id, None, None);
            event.causality = causality_from_context(&ctx);
            events.push(event);
        }
    }

    // Events are sorted by recorded_at_ms already (monotonic ts)
    let config = InvariantCheckerConfig {
        check_merge_order: true,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);

    assert!(report.passed, "violations: {:?}", report.violations);
    assert_eq!(report.events_checked, 50);
    assert_eq!(report.panes_observed, 5);
}

#[test]
fn deterministic_event_ids_are_unique() {
    let assigner = SequenceAssigner::new();

    let mut ids = std::collections::HashSet::new();
    for pane_id in 0u64..10 {
        for _ in 0..50 {
            let (pane_seq, _) = assigner.assign(pane_id);
            let ts = 1000 + pane_seq * 10 + pane_id;
            let event = build_event(
                pane_id,
                pane_seq,
                ts,
                ingress_payload("hello"),
                empty_causality(),
            );
            assert!(
                ids.insert(event.event_id.clone()),
                "duplicate event_id: {}",
                event.event_id
            );
        }
    }
    assert_eq!(ids.len(), 500);
}

#[test]
fn deterministic_event_ids_are_stable_across_regeneration() {
    let assigner = SequenceAssigner::new();
    let (pane_seq, _) = assigner.assign(0);

    let event = build_event(
        0,
        pane_seq,
        1000,
        ingress_payload("stable"),
        empty_causality(),
    );
    let id1 = event.event_id.clone();

    // Rebuild the same event from scratch — ID should match
    let mut event2 = RecorderEvent {
        schema_version: RECORDER_EVENT_SCHEMA_VERSION_V1.to_string(),
        event_id: String::new(),
        pane_id: 0,
        session_id: Some("integration-test".into()),
        workflow_id: None,
        correlation_id: None,
        source: RecorderEventSource::RobotMode,
        occurred_at_ms: 1000,
        recorded_at_ms: 1001,
        sequence: 0,
        causality: empty_causality(),
        payload: ingress_payload("stable"),
    };
    event2.event_id = generate_event_id_v1(&event2);

    assert_eq!(id1, event2.event_id, "event IDs must be deterministic");
}

#[test]
fn correlation_tracker_builds_valid_causal_chains() {
    let assigner = SequenceAssigner::new();
    let tracker = CorrelationTracker::new();
    let pane_id = 0u64;

    let mut events = Vec::new();

    // First event: no parent
    let (seq0, _) = assigner.assign(pane_id);
    let e0 = build_event(
        pane_id,
        seq0,
        1000,
        ingress_payload("first"),
        empty_causality(),
    );
    let ctx0 = tracker.build_context(pane_id, &e0.event_id, None, None);
    assert!(ctx0.parent_event_id.is_none());
    let mut e0_final = e0.clone();
    e0_final.causality = causality_from_context(&ctx0);
    events.push(e0_final);

    // Second event: parent = first
    let (seq1, _) = assigner.assign(pane_id);
    let e1 = build_event(
        pane_id,
        seq1,
        1010,
        ingress_payload("second"),
        empty_causality(),
    );
    let ctx1 = tracker.build_context(pane_id, &e1.event_id, None, None);
    assert_eq!(ctx1.parent_event_id.as_deref(), Some(e0.event_id.as_str()));
    let mut e1_final = e1.clone();
    e1_final.causality = causality_from_context(&ctx1);
    events.push(e1_final);

    // Third event: parent = second, trigger = first (response)
    let (seq2, _) = assigner.assign(pane_id);
    let e2 = build_event(
        pane_id,
        seq2,
        1020,
        ingress_payload("third"),
        empty_causality(),
    );
    let ctx2 = tracker.build_context(
        pane_id,
        &e2.event_id,
        Some(&e0.event_id),
        Some(&e0.event_id),
    );
    assert_eq!(ctx2.parent_event_id.as_deref(), Some(e1.event_id.as_str()));
    assert_eq!(ctx2.trigger_event_id.as_deref(), Some(e0.event_id.as_str()));
    let mut e2_final = e2.clone();
    e2_final.causality = causality_from_context(&ctx2);
    events.push(e2_final);

    // Invariant check: all causal references should be valid
    let config = InvariantCheckerConfig {
        check_merge_order: false,
        check_causality: true,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);

    assert!(report.passed, "violations: {:?}", report.violations);
    assert_eq!(report.count_by_kind(ViolationKind::DanglingParentRef), 0);
    assert_eq!(report.count_by_kind(ViolationKind::DanglingTriggerRef), 0);
    assert_eq!(report.count_by_kind(ViolationKind::DanglingRootRef), 0);
}

#[test]
fn replay_order_matches_merge_key_ordering() {
    let assigner = SequenceAssigner::new();

    let mut events = Vec::new();
    let mut replay_orders = Vec::new();

    // Generate events across multiple panes
    for round in 0u64..5 {
        for pane_id in 0u64..3 {
            let (pane_seq, global_seq) = assigner.assign(pane_id);
            let ts = 1000 + round * 30 + pane_id * 10;
            let event = build_event(
                pane_id,
                pane_seq,
                ts,
                ingress_payload("data"),
                empty_causality(),
            );
            replay_orders.push(ReplayOrder::new(global_seq, pane_id, pane_seq));
            events.push(event);
        }
    }

    // Validate replay order is valid
    let violations = validate_replay_order(&replay_orders);
    assert!(violations.is_empty(), "violations: {:?}", violations);

    // Sort by RecorderMergeKey and by ReplayOrder — verify compatible ordering
    let mut merge_keys: Vec<(usize, RecorderMergeKey)> = events
        .iter()
        .enumerate()
        .map(|(i, e)| (i, RecorderMergeKey::from_event(e)))
        .collect();
    merge_keys.sort_by(|a, b| a.1.cmp(&b.1));

    let mut replay_sorted: Vec<(usize, ReplayOrder)> = replay_orders
        .iter()
        .enumerate()
        .map(|(i, o)| (i, *o))
        .collect();
    replay_sorted.sort_by(|a, b| a.1.cmp(&b.1));

    // Both orderings should place all events for pane 0 before pane 1 etc
    // (because timestamps increase monotonically within each round)
    // Verify no merge key violations
    let config = InvariantCheckerConfig {
        check_merge_order: true,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);
    assert_eq!(
        report.count_by_kind(ViolationKind::MergeOrderViolation),
        0,
        "merge key violations: {:?}",
        report.violations
    );
}

#[test]
fn replay_determinism_after_shuffle_and_resort() {
    let assigner = SequenceAssigner::new();

    let mut events = Vec::new();
    for pane_id in 0u64..4 {
        for _ in 0..10 {
            let (pane_seq, _) = assigner.assign(pane_id);
            let ts = 1000 + pane_seq * 10 + pane_id;
            let event = build_event(
                pane_id,
                pane_seq,
                ts,
                ingress_payload("data"),
                empty_causality(),
            );
            events.push(event);
        }
    }

    // Shuffle order deterministically
    let mut shuffled = events.clone();
    // Reverse to simulate out-of-order arrival
    shuffled.reverse();

    // Replay determinism: sorted keys should match regardless of input order
    let result = verify_replay_determinism(&events, &shuffled);
    assert!(
        result.deterministic,
        "replay divergence: {}",
        result.message
    );
}

#[test]
fn mixed_event_types_across_streams_pass_invariants() {
    let assigner = SequenceAssigner::new();
    let pane_id = 0u64;

    let mut events = Vec::new();

    // Lifecycle: capture started
    let (seq, _) = assigner.assign(pane_id);
    events.push(build_event(
        pane_id,
        seq,
        1000,
        lifecycle_payload(RecorderLifecyclePhase::CaptureStarted),
        empty_causality(),
    ));

    // Ingress: command sent
    let (seq, _) = assigner.assign(pane_id);
    events.push(build_event(
        pane_id,
        seq,
        1010,
        ingress_payload("ls -la"),
        empty_causality(),
    ));

    // Egress: output received
    let (seq, _) = assigner.assign(pane_id);
    events.push(build_event(
        pane_id,
        seq,
        1020,
        egress_payload("total 42\ndrwxr-xr-x"),
        empty_causality(),
    ));

    // Control: prompt boundary
    let (seq, _) = assigner.assign(pane_id);
    events.push(build_event(
        pane_id,
        seq,
        1030,
        RecorderEventPayload::ControlMarker {
            control_marker_type:
                frankenterm_core::recording::RecorderControlMarkerType::PromptBoundary,
            details: serde_json::json!({"osc": "133"}),
        },
        empty_causality(),
    ));

    // Lifecycle: capture stopped
    let (seq, _) = assigner.assign(pane_id);
    events.push(build_event(
        pane_id,
        seq,
        1040,
        lifecycle_payload(RecorderLifecyclePhase::CaptureStopped),
        empty_causality(),
    ));

    // Check invariants — note: all events share the same pane but different
    // stream kinds (lifecycle, ingress, egress, control), so they're in
    // separate domains with independent sequences
    let config = InvariantCheckerConfig {
        check_merge_order: true,
        check_causality: true,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);
    assert!(report.passed, "violations: {:?}", report.violations);
    assert_eq!(report.panes_observed, 1);
    // 4 different stream kinds
    assert!(report.domains_observed >= 3);
}

#[test]
fn batch_correlation_chain_passes_invariants() {
    let assigner = SequenceAssigner::new();
    let tracker = CorrelationTracker::new();
    let pane_id = 0u64;

    let mut events = Vec::new();

    // Start a batch
    tracker.start_batch(pane_id, "batch-001".into());

    for i in 0u64..5 {
        let (pane_seq, _) = assigner.assign(pane_id);
        let ts = 1000 + i * 10;
        let mut event = build_event(
            pane_id,
            pane_seq,
            ts,
            ingress_payload(&format!("batch-cmd-{}", i)),
            empty_causality(),
        );
        let ctx = tracker.build_context(pane_id, &event.event_id, None, None);
        event.causality = causality_from_context(&ctx);
        // Verify batch_id is set
        assert_eq!(ctx.batch_id.as_deref(), Some("batch-001"));
        events.push(event);
    }

    tracker.end_batch(pane_id);

    // Post-batch event has no batch_id
    let (pane_seq, _) = assigner.assign(pane_id);
    let mut event = build_event(
        pane_id,
        pane_seq,
        1060,
        ingress_payload("after-batch"),
        empty_causality(),
    );
    let ctx = tracker.build_context(pane_id, &event.event_id, None, None);
    assert!(ctx.batch_id.is_none());
    event.causality = causality_from_context(&ctx);
    events.push(event);

    // Invariant check
    let config = InvariantCheckerConfig {
        check_merge_order: false,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);
    assert!(report.passed, "violations: {:?}", report.violations);
}

#[test]
fn stream_kind_from_payload_matches_event_type() {
    let payloads = vec![
        (ingress_payload("test"), StreamKind::Ingress),
        (egress_payload("output"), StreamKind::Egress),
        (
            lifecycle_payload(RecorderLifecyclePhase::PaneOpened),
            StreamKind::Lifecycle,
        ),
        (
            RecorderEventPayload::ControlMarker {
                control_marker_type: frankenterm_core::recording::RecorderControlMarkerType::Resize,
                details: serde_json::Value::Null,
            },
            StreamKind::Control,
        ),
    ];

    for (payload, expected_kind) in payloads {
        let kind = StreamKind::from_payload(&payload);
        assert_eq!(kind, expected_kind, "mismatch for payload: {:?}", payload);
    }
}

#[test]
fn merge_keys_sort_by_recorded_at_then_pane_then_stream_then_sequence() {
    // Two events at same recorded_at_ms, different panes
    let events = [
        build_event(1, 0, 1000, ingress_payload("p1"), empty_causality()),
        build_event(0, 0, 1000, ingress_payload("p0"), empty_causality()),
    ];

    let mut keys: Vec<RecorderMergeKey> = events.iter().map(RecorderMergeKey::from_event).collect();
    keys.sort();

    // pane_id 0 < pane_id 1 when recorded_at ties
    assert!(keys[0].pane_id <= keys[1].pane_id);
}

#[test]
fn large_scale_correctness_500_events_10_panes() {
    let assigner = SequenceAssigner::new();
    let tracker = CorrelationTracker::new();

    let mut events = Vec::new();

    for round in 0u64..50 {
        for pane_id in 0u64..10 {
            let (pane_seq, _) = assigner.assign(pane_id);
            let ts = 1000 + round * 100 + pane_id;
            let mut event = build_event(
                pane_id,
                pane_seq,
                ts,
                ingress_payload("data"),
                empty_causality(),
            );
            let ctx = tracker.build_context(pane_id, &event.event_id, None, None);
            event.causality = causality_from_context(&ctx);
            events.push(event);
        }
    }

    // Full invariant check
    let config = InvariantCheckerConfig {
        check_merge_order: true,
        check_causality: true,
        expected_schema_version: RECORDER_EVENT_SCHEMA_VERSION_V1.to_string(),
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);

    assert!(report.passed, "violations: {:?}", report.violations);
    assert_eq!(report.events_checked, 500);
    assert_eq!(report.panes_observed, 10);
    assert!(!report.has_critical());
    assert!(!report.has_errors());

    // Verify all event IDs are unique
    let ids: std::collections::HashSet<&str> = events.iter().map(|e| e.event_id.as_str()).collect();
    assert_eq!(ids.len(), 500);

    // Verify replay determinism with reversed order
    let mut reversed = events.clone();
    reversed.reverse();
    let result = verify_replay_determinism(&events, &reversed);
    assert!(
        result.deterministic,
        "replay divergence: {}",
        result.message
    );
}

#[test]
fn cross_pane_trigger_response_chain_passes() {
    let assigner = SequenceAssigner::new();
    let tracker = CorrelationTracker::new();

    let mut events = Vec::new();

    // Pane 0: root event
    let (seq0, _) = assigner.assign(0);
    let root = build_event(
        0,
        seq0,
        1000,
        ingress_payload("root-cmd"),
        empty_causality(),
    );
    let ctx0 = tracker.build_context(0, &root.event_id, None, None);
    let mut root_final = root.clone();
    root_final.causality = causality_from_context(&ctx0);
    events.push(root_final);

    // Pane 1: triggered by pane 0's root event
    let (seq1, _) = assigner.assign(1);
    let resp = build_event(1, seq1, 1010, egress_payload("response"), empty_causality());
    let ctx1 = tracker.build_context(
        1,
        &resp.event_id,
        Some(&root.event_id),
        Some(&root.event_id),
    );
    let mut resp_final = resp.clone();
    resp_final.causality = causality_from_context(&ctx1);
    events.push(resp_final);

    // Pane 2: triggered by pane 1, root = pane 0
    let (seq2, _) = assigner.assign(2);
    let e2 = build_event(2, seq2, 1020, ingress_payload("cascade"), empty_causality());
    let ctx2 = tracker.build_context(2, &e2.event_id, Some(&resp.event_id), Some(&root.event_id));
    let mut e2_final = e2.clone();
    e2_final.causality = causality_from_context(&ctx2);
    events.push(e2_final);

    let config = InvariantCheckerConfig {
        check_merge_order: false,
        check_causality: true,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);

    assert!(report.passed, "violations: {:?}", report.violations);
    assert_eq!(report.count_by_kind(ViolationKind::DanglingTriggerRef), 0);
    assert_eq!(report.count_by_kind(ViolationKind::DanglingRootRef), 0);
}

#[test]
fn intentionally_corrupted_pipeline_detected() {
    let assigner = SequenceAssigner::new();

    let mut events = Vec::new();

    // Valid first event
    let (seq0, _) = assigner.assign(0);
    events.push(build_event(
        0,
        seq0,
        1000,
        ingress_payload("ok"),
        empty_causality(),
    ));

    // Inject corrupted event: sequence regression
    events.push(build_event(
        0,
        0,
        1010,
        ingress_payload("dup-seq"),
        empty_causality(),
    ));

    // Inject corrupted event: duplicate event_id (same content)
    let dup = events[0].clone();
    events.push(dup);

    // Inject corrupted event: dangling parent ref
    let mut dangling = build_event(0, 99, 1020, ingress_payload("orphan"), empty_causality());
    dangling.causality.parent_event_id = Some("nonexistent-event".into());
    events.push(dangling);

    let config = InvariantCheckerConfig {
        check_merge_order: false,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);

    assert!(!report.passed);
    assert!(report.has_critical()); // duplicate event_id is critical
    // Both the injected dup-seq event AND the cloned event share seq=0
    assert_eq!(report.count_by_kind(ViolationKind::DuplicateSequence), 2);
    assert_eq!(report.count_by_kind(ViolationKind::DuplicateEventId), 1);
    assert_eq!(report.count_by_kind(ViolationKind::DanglingParentRef), 1);
}

#[test]
fn sequence_assigner_replay_order_is_valid() {
    let assigner = SequenceAssigner::new();

    let mut orders = Vec::new();
    for _ in 0..100 {
        for pane_id in 0u64..5 {
            let (pane_seq, global_seq) = assigner.assign(pane_id);
            orders.push(ReplayOrder::new(global_seq, pane_id, pane_seq));
        }
    }

    let violations = validate_replay_order(&orders);
    assert!(violations.is_empty(), "violations: {:?}", violations);
}

#[test]
fn clock_regression_flagged_as_warning_not_failure() {
    let assigner = SequenceAssigner::new();

    let mut events = Vec::new();

    // Normal timestamp
    let (seq0, _) = assigner.assign(0);
    events.push(build_event(
        0,
        seq0,
        2000,
        ingress_payload("a"),
        empty_causality(),
    ));

    // Clock regression: timestamp goes backwards
    let (seq1, _) = assigner.assign(0);
    events.push(build_event(
        0,
        seq1,
        1000,
        ingress_payload("b"),
        empty_causality(),
    ));

    let config = InvariantCheckerConfig {
        check_merge_order: false,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&events);

    // Clock regressions are warnings — the report should still pass
    assert!(report.passed);
    assert_eq!(report.count_by_severity(ViolationSeverity::Warning), 1);
    assert_eq!(report.count_by_kind(ViolationKind::ClockRegression), 1);
}

#[test]
fn pane_reset_produces_valid_new_sequence() {
    let assigner = SequenceAssigner::new();

    // Assign some sequences for pane 0
    for _ in 0..5 {
        assigner.assign(0);
    }
    assert_eq!(assigner.current_pane(0), 5);

    // Reset pane 0
    assigner.reset_pane(0);

    // New sequence starts at 0 again
    let (pane_seq, _) = assigner.assign(0);
    assert_eq!(pane_seq, 0);

    // Global sequence continues monotonically
    assert!(assigner.current_global() > 5);
}

#[test]
fn serde_roundtrip_preserves_invariant_compliance() {
    let assigner = SequenceAssigner::new();

    let mut events = Vec::new();
    for pane_id in 0u64..3 {
        for _ in 0..5 {
            let (pane_seq, _) = assigner.assign(pane_id);
            let ts = 1000 + pane_seq * 10 + pane_id;
            events.push(build_event(
                pane_id,
                pane_seq,
                ts,
                ingress_payload("test"),
                empty_causality(),
            ));
        }
    }

    // Serialize to JSON and back
    let json = serde_json::to_string(&events).expect("serialize");
    let deserialized: Vec<RecorderEvent> = serde_json::from_str(&json).expect("deserialize");

    // Check invariants on deserialized events
    let config = InvariantCheckerConfig {
        check_merge_order: false,
        ..Default::default()
    };
    let checker = InvariantChecker::with_config(config);
    let report = checker.check(&deserialized);
    assert!(
        report.passed,
        "serde roundtrip broke invariants: {:?}",
        report.violations
    );

    // Replay determinism should hold
    let result = verify_replay_determinism(&events, &deserialized);
    assert!(result.deterministic);
}
